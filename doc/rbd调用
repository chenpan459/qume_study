根据提供的代码，我来分析一下QEMU中librbd库的加载和调用方法：

## 1. 库的加载方式

### 编译时链接
从代码中可以看出，librbd是通过编译时链接的方式加载的：

- 在文件开头包含了librbd头文件：`#include <rbd/librbd.h>`
- 直接调用librbd的API函数，如 `rbd_create()`、`rbd_open()` 等

### 条件编译支持
代码中使用了多个宏定义来支持不同版本的librbd：

```c
#ifdef LIBRBD_SUPPORTS_ENCRYPTION
// 加密相关功能
#endif

#ifdef LIBRBD_SUPPORTS_WRITE_ZEROES
// write_zeroes功能支持
#endif
```

## 2. 主要调用流程

### 连接和初始化
```c
// 创建RADOS集群句柄
r = rados_create(cluster, opts->user);

// 读取配置文件
r = rados_conf_read_file(*cluster, opts->conf);

// 设置配置参数
r = rados_conf_set(*cluster, "mon_host", mon_host);

// 连接到集群
r = rados_connect(*cluster);

// 创建I/O上下文
r = rados_ioctx_create(*cluster, opts->pool, io_ctx);
```

### 镜像操作
```c
// 创建镜像
ret = rbd_create(io_ctx, opts->location->image, opts->size, &obj_order);

// 打开镜像
r = rbd_open(s->io_ctx, s->image_name, &s->image, s->snap);

// 获取镜像信息
r = rbd_stat(s->image, &info, sizeof(info));

// 关闭镜像
rbd_close(s->image);
```

### 异步I/O操作
使用异步I/O操作时，通过回调机制处理完成通知：

```c
// 创建完成回调
r = rbd_aio_create_completion(&task, (rbd_callback_t) qemu_rbd_completion_cb, &c);

// 异步读取
r = rbd_aio_readv(s->image, qiov->iov, qiov->niov, offset, c);

// 异步写入
r = rbd_aio_writev(s->image, qiov->iov, qiov->niov, offset, c);
```

## 3. 特殊处理机制

### 加密支持
当librbd支持加密时，可以格式化和加载加密镜像：
```c
#ifdef LIBRBD_SUPPORTS_ENCRYPTION
r = rbd_encryption_format(image, format, opts, opts_size);
r = rbd_encryption_load(image, format, opts, opts_size);
#endif
```

### 快照操作
```c
// 创建快照
r = rbd_snap_create(s->image, sn_info->name);

// 删除快照
r = rbd_snap_remove(s->image, snapshot_name);

// 回滚快照
r = rbd_snap_rollback(s->image, snapshot_name);
```

## 4. 错误处理
所有librbd调用的返回值都会被检查，负值表示错误：
```c
if (r < 0) {
    error_setg_errno(errp, -r, "error message");
    return r;
}
```

## 5. 构建系统集成
librbd的支持通常在QEMU的构建系统中通过pkg-config检测：
```
# 在配置阶段检查librbd
PKG_CHECK_MODULES([RBD], [rbd >= 0.1.8], [], [rbd_found=no])
```

这种设计使得QEMU可以在运行时使用librbd库提供的所有功能，同时通过条件编译支持不同版本的librbd库。